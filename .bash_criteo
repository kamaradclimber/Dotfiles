# /* vim: set filetype=sh : */


__whereami() {
  if grep 'search criteois.lan' /etc/resolv.conf > /dev/null ; then
    echo "criteo"
  # 78.194.186.226 is home fixed ipaddress
  # 91.199.242.* is the address of criteo when using the vpn
  elif curl -s icanhazip.com | grep -q -e 78.194.186.226 -e 91.199.242.; then
    echo "home"
  elif host 192.168.1.1 | grep -q -e neufbox; then
    echo "SPDO"
  else
    echo "elsewhere"
  fi
}


# use this method to get cached access to localization
__cached_whereami() {
  local tmp=/tmp/whereami.cache
  if test -f $tmp; then
    [[ -z "$(find $tmp -mmin +30)" ]] && cat $tmp && return 0
  fi
  __whereami | tee $tmp
}

__mothership() {
  local home=familleseux.net
  case $(__cached_whereami) in
    mothership )
      echo "ssh grego@capodimonte";;
    *)
      echo "ssh grego@$home";;
  esac
}

__homepage() {
  case $(__cached_whereami) in
    criteo )
      export HOMEPAGE='https://jira.criteois.com/secure/RapidBoard.jspa?rapidView=1829'
  esac
}

__homepage

function knife_until {
  if [ $# -ne 1 ]; then
    echo "USAGE: $0 <NODE_NAME>" >&2
    exit 1
  fi
  NODE_NAME=$1
  START_TIME=$(date +%s)
  CURRENT_TIME=${START_TIME}
  KNIFE_OPTS="-i -R 1"
  TIMEOUT_TIME=$(date -d "${TIMEOUT} seconds" +%s)
  while ! bundle exec knife search node "name:${NODE_NAME} AND ohai_time:[${START_TIME} TO ${CURRENT_TIME}]" ${KNIFE_OPTS} 2>&1 | grep -q ${NODE_NAME};
  do
    echo -n .
    sleep 30
    CURRENT_TIME=$(date +%s)
  done
}

function j {
  xdg-open http://jira.criteois.com/browse/$1
}

export CRITEO_USER=g.seux

function kitchenec2 {
  source ~/.env
  KITCHEN_YAML=.kitchen.ec2.yml bundle exec kitchen $@
}

alias gogogo='ssh -D 1080 -Nn criteo'

# Smart cd for criteo projects
_gitlab_clone() {
  project=$1
  repo=$2
  dir=$3
  git clone git@gitlab.criteois.com:$project/$repo.git $dir
}

_gerrit_clone() {
  project=$1
  repo=$2
  dir=$3
  echo git clone ssh://review.criteois.lan:29418/$project/$repo.git $dir
  git clone ssh://review.criteois.lan:29418/$project/$repo.git $dir
}

gerrit() {
  local project=$(dirname $1)
  local repo=$(basename $1)
  mkdir -p ~/$project
  [[ ! -d ~/$1 ]] && _gerrit_clone "$project" "$repo" "$HOME/$1"
  cd ~/$1
}

add_gitlab_remote() {
  path=$1
  if git remote -v | grep -q review; then
    (git remote -v | grep -q gitlab) || git remote add gitlab git@gitlab.criteois.com:$path.git
  elif git remote -v | grep -q gitlab; then
    git remote -v | grep gitlab | awk '{print $1}' | xargs -n1 git remote remove
  fi
}

ck() {
  gerrit chef-cookbooks/$1
  add_gitlab_remote chef-cookbooks/$1
}
_ck_complete() {
  local cur=${COMP_WORDS[COMP_CWORD]}
  COMPREPLY=( $(compgen -W "$(command ls ~/chef-cookbooks/)" -- $cur) )
}
complete -o default -F _ck_complete ck
repo() {
  shortname=$(echo $1 | sed -re 's/^(chef-)?//')
  fullname=$(echo $1 | sed -re 's/^(chef-)?/chef-/')
  gerrit chef-repositories/$fullname
  add_gitlab_remote chef-repositories/$fullname
}
_repo_complete() {
  local cur=${COMP_WORDS[COMP_CWORD]}
  COMPREPLY=( $(compgen -W "$(command ls ~/chef-repositories/)" -- $cur) )
}
complete -o default -F _repo_complete repo
rubygem () {
  gerrit ruby-gems/$1
  add_gitlab_remote ruby-gems/$1
}
_gem_complete() {
  local cur=${COMP_WORDS[COMP_CWORD]}
  COMPREPLY=( $(compgen -W "$(command ls ~/ruby-gems/)" -- $cur) )
}
complete -o default -F _gem_complete rubygem
# end of smart


function rdesktop() {
  rdesktop_base="command rdesktop -K -g 1200x800"
  dc=$(echo $1 | sed -re 's/[^\.]+\.([^\.]+)\..+/\1/')
  if [ ! -z "$dc" ]; then
    echo "Inserting '$dc' as domain name"
    password=$(cat ~/.watson_env | grep SSH_PERSONAL_PASSWORD | cut -d"'" -f2)
    $rdesktop_base -d $dc -u $CRITEO_USER -p "$password" $1
  else
    echo "No dc found, fallback to normal rdesktop"
    $rdesktop_base $1
  fi
}


rack_info()
{
 curl -s "https://rackenstein-api.crto.in/devices?serial_no=$1" | jq '.'
}

rack_ext_info()
{
 curl -s "https://rackenstein-api.crto.in/device/id/$(curl -s "https://rackenstein-api.crto.in/devices?serial_no=$1" | jq '.data.devices[0].id' | sed -e 's/"//g')/" | jq '.'
}

rack_vlan_info()
{
 rack_ext_info $1 | jq -r '.data[0].device_interface[] | .switch_port.vlan | select(.!=null)'
}

chef_serial_from_nodename()
{
 knife node show $1 -a dmi.system.serial_number | grep "^ " | awk '{ print $2 }'
}
